const fs = require('fs');
const path = require('path');
const { Document, Packer, Paragraph, TextRun } = require('docx');

const inputPath = path.join(__dirname, 'shelf.bibtex');
const outputPath = path.join(__dirname, 'sorted_shelf.docx');

const rawData = fs.readFileSync(inputPath, 'utf8');

// Split entries robustly
const entries = rawData
  .split(/(?=^@)/m)
  .map(e => e.trim())
  .filter(Boolean);

// Extract ALL occurrences of a property
function getProps(entry, propName) {
  const regex = new RegExp(`${propName}\\s*=\\s*\\{([^}]*)\\}`, 'gi');
  let match;
  const values = [];
  while ((match = regex.exec(entry)) !== null) {
    values.push(match[1].trim());
  }
  return values;
}

// Helper: get first value
function getFirst(entry, propName) {
  const vals = getProps(entry, propName);
  return vals.length > 0 ? vals[0] : '';
}

// Helper: get joined values with deduplication
function getJoined(entry, propName, sep = '; ') {
  const vals = getProps(entry, propName);
  const unique = [...new Set(vals)]; // remove duplicates
  return unique.join(sep);
}

// Format a book in ISBD style
function formatBook(entry) {
  const sortWord = getFirst(entry, 'sort_word') || getFirst(entry, 'author') || '';
  const author = getFirst(entry, 'author') || '';
  const title = getFirst(entry, 'title') || '';
  const subtitle = getFirst(entry, 'subtitle') || getFirst(entry, 'substitle') || '';
  const responsibility = getFirst(entry, 'responsibility') || author;
  const edition = getJoined(entry, 'edition');
  const place = getFirst(entry, 'address') || getFirst(entry, 'place') || '';
  const publisher = getFirst(entry, 'publisher') || '';
  const year = getFirst(entry, 'year') || '';
  const extent = getFirst(entry, 'page_count') || getFirst(entry, 'extent') || '';
  const dimensions = getFirst(entry, 'illustrations') || getFirst(entry, 'dimensions') || '';
  const series = getFirst(entry, 'series') || '';
  const isbn = getFirst(entry, 'isbn') || '';
  const note = getFirst(entry, 'abstract') || '';
  const book_info = getFirst(entry, 'book_info') || '';
  const otherSources = getJoined(entry, 'other_sources');
  const itemTypes = [...new Set(getProps(entry, 'item_type').map(v => v.toUpperCase()))];

  let line1 = `${sortWord}`;
  let line2 = `  ${title}`;
  if (subtitle) line2 += ` : ${subtitle}`;
  if (responsibility) line2 += ` / ${responsibility}`;
  if (edition) line2 += `. – ${edition}`;
  if (book_info) line2 += `. – ${book_info}`;

  if (place || publisher || year) {
    let pubBlock = '';
    if (place) pubBlock += place;
    if (publisher) pubBlock += (pubBlock ? ' : ' : '') + publisher;
    if (year) pubBlock += (pubBlock ? ', ' : '') + year;
    line2 += `. – ${pubBlock}`;
  }

  if (extent || dimensions) {
    let physBlock = '';
    if (extent) physBlock += extent;
    if (dimensions) physBlock += (physBlock ? ' ; ' : '') + dimensions;
    line2 += `. – ${physBlock}`;
  }

  if (series) line2 += `. – (${series})`;
  if (isbn) line2 += `. – ISBN ${isbn}`;
  if (otherSources) line2 += `. – ${otherSources}`;
  if (itemTypes.length > 0) line2 += `. – Item types: ${itemTypes.join(', ')}`;

  return { mainLine: `${line1}\n${line2}`, note };
}

// Format an article in ISBD style
function formatArticle(entry) {
  const sortWord = getFirst(entry, 'sort_word') || '';
  const author = getFirst(entry, 'author') || '';
  const title = getFirst(entry, 'title') || '';
  const source = getFirst(entry, 'source') || '';
  const number = getFirst(entry, 'number') || '';
  const year = getFirst(entry, 'year') || '';
  const pages = getFirst(entry, 'art_pages') || '';
  const note = getFirst(entry, 'abstract') || '';
  const otherSources = getJoined(entry, 'other_sources');
  const itemTypes = [...new Set(getProps(entry, 'item_type').map(v => v.toUpperCase()))];

  let line1 = `${sortWord}`;
  let line2 = `  ${title} / ${author}. - В: ${source}`;
  if (number) line2 += `. - бр. ${number}`;
  line2 += `, (${year}), ${pages}`;
  if (otherSources) line2 += `. – ${otherSources}`;
  if (itemTypes.length > 0) line2 += `. – Item types: ${itemTypes.join(', ')}`;

  return { mainLine: `${line1}\n${line2}`, note };
}

// Parse for sorting
const parsed = entries.map(entry => {
  const itemTypes = getProps(entry, 'item_type').map(v => v.toUpperCase());
  const primaryType = itemTypes.length > 0 ? itemTypes[0] : '';
  const year = parseInt(getFirst(entry, 'year'), 10) || 0;
  return { entry, itemTypes, itemType: primaryType, year };
});

// Sort: KNG first, then others; within group by year ASC
parsed.sort((a, b) => {
  const aIsKNG = a.itemType === 'KNG';
  const bIsKNG = b.itemType === 'KNG';

  if (aIsKNG && !bIsKNG) return -1;
  if (!aIsKNG && bIsKNG) return 1;

  return a.year - b.year;
});

// Split into categories
const books = parsed.filter(p => p.itemType === 'KNG');
const articles = parsed.filter(p => ['JOU', 'KRA', 'ARTICLE'].includes(p.itemType));

// Counts for summary
const total = parsed.length;
const bookCount = books.length;
const articleCount = articles.length;

// Build DOCX
const children = [];

children.push(
  new Paragraph({
    children: [new TextRun({ text: `Общо записи: ${total} (Книги: ${bookCount}, Статии: ${articleCount})`, bold: true })]
  }),
  new Paragraph({ text: '' })
);

if (books.length > 0) {
  children.push(new Paragraph({ children: [new TextRun({ text: 'КНИГИ', bold: true })] }));
  books.forEach(b => {
    const { mainLine, note } = formatBook(b.entry);
    mainLine.split('\n').forEach(line => children.push(new Paragraph({ text: line })));
    if (note) children.push(new Paragraph({ text: note }));
    children.push(new Paragraph({ text: '' }));
  });
}

if (articles.length > 0) {
  children.push(new Paragraph({ children: [new TextRun({ text: 'СТАТИИ', bold: true })] }));
  articles.forEach(a => {
    const { mainLine, note } = formatArticle(a.entry);
    mainLine.split('\n').forEach(line => children.push(new Paragraph({ text: line })));
    if (note) children.push(new Paragraph({ text: note }));
    children.push(new Paragraph({ text: '' }));
  });
}

const doc = new Document({ sections: [{ children }] });

Packer.toBuffer(doc).then(buffer => {
  fs.writeFileSync(outputPath, buffer);
  console.log(`Sorted DOCX saved to ${outputPath}`);
});
