const fs = require("fs");
const path = require("path");
const { Document, Packer, Paragraph, TextRun } = require("docx");

const inputPath = path.join(__dirname, "shelf_test.bibtex");
const outputPath = path.join(__dirname, "sorted_shelf.docx");

const rawData = fs.readFileSync(inputPath, "utf8");

// Split entries robustly
const entries = rawData
  .split(/(?=^@)/m)
  .map((e) => e.trim())
  .filter(Boolean);

// Extract ALL occurrences of a property
function getProps(entry, propName) {
  const regex = new RegExp(`${propName}\\s*=\\s*\\{([^}]*)\\}`, "gi");
  let match;
  const values = [];
  while ((match = regex.exec(entry)) !== null) {
    values.push(match[1].trim());
  }
  return values;
}

// Helper: get first value
function getFirst(entry, propName) {
  const vals = getProps(entry, propName);
  return vals.length > 0 ? vals[0] : "";
}

// Helper: get joined values with deduplication
function getJoined(entry, propName, sep = "; ") {
  const vals = getProps(entry, propName);
  const unique = [...new Set(vals)];
  return unique.join(sep);
}

// ============================
// Notes cleaner
// ============================
function cleanNotes(entry) {
  const notesRaw = getProps(entry, "abstract");
  return notesRaw.map((n) => n.replace(/^Съдържа и:\s*/i, "").trim());
}

// ============================
// Formatting Functions
// ============================

function formatBook(entry) {
  const main_sig = getFirst(entry, "main_sig") || "";
  const dep_sig = getFirst(entry, "dep_sig") || "";
  const sortWord = getFirst(entry, "sort_word") || getFirst(entry, "author") || "";
  const author = getFirst(entry, "author") || "";
  let title = getFirst(entry, "title") || "";
  const subtitle = getFirst(entry, "subtitle") || getFirst(entry, "substitle") || "";
  const responsibility = getFirst(entry, "responsibility") || author;
  const edition = getJoined(entry, "edition");
  const place = getFirst(entry, "address") || getFirst(entry, "place") || "";
  const publisher = getFirst(entry, "publisher") || "";
  const year = getFirst(entry, "year") || "";
  const extent = getFirst(entry, "page_count") || getFirst(entry, "extent") || "";
  const dimensions = getFirst(entry, "illustrations") || getFirst(entry, "dimensions") || "";
  const series = getFirst(entry, "series") || "";
  const isbn = getFirst(entry, "isbn") || "";
  const book_info = getFirst(entry, "book_info") || "";
  const otherSources = getJoined(entry, "other_sources");
  const itemTypes = [...new Set(getProps(entry, "item_type").map((v) => v.toUpperCase()))];
  const aboutPersons = getJoined(entry, "about_person", "; ");

  const notes = cleanNotes(entry);

  let line01 = `${main_sig}`;
  line01 += `       ${dep_sig}`;

  let line1 = `${sortWord}`;

  if (itemTypes.includes("CDD")) {
    title += " [CD-ROM]";
  }

  let line2 = `  ${title}`;
  if (subtitle) line2 += ` : ${subtitle}`;
  if (responsibility) line2 += ` / ${responsibility}`;
  if (edition) line2 += `. – ${edition}`;
  if (book_info) line2 += `. – ${book_info}`;

  if (place || publisher || year) {
    let pubBlock = "";
    if (place) pubBlock += place;
    if (publisher) pubBlock += (pubBlock ? " : " : "") + publisher;
    if (year) pubBlock += (pubBlock ? ", " : "") + year;
    line2 += `. – ${pubBlock}`;
  }

  if (extent || dimensions) {
    let physBlock = "";
    if (extent) physBlock += extent;
    if (dimensions) physBlock += (physBlock ? " ; " : "") + dimensions;
    line2 += `. – ${physBlock}`;
  }

  if (series) line2 += `. – (${series})`;
  if (isbn) line2 += `. – ISBN ${isbn}`;
  if (otherSources) line2 += `. – ${otherSources}`;

  let itemTypeLine = "";
  if (itemTypes.length > 0) {
    itemTypeLine = `Item types: ${itemTypes.join(", ")}`;
  }

  return { mainLine: `${line01}\n${line1}\n${line2}`, notes, itemTypeLine, aboutPersons };
}

function formatArticle(entry) {
  const sortWord = getFirst(entry, "sort_word") || "";
  const author = getFirst(entry, "author") || "";
  let title = getFirst(entry, "title") || "";
  const source = getFirst(entry, "source") || "";
  const number = getFirst(entry, "number") || "";
  const year = getFirst(entry, "year") || "";
  const pages = getFirst(entry, "art_pages") || "";
  const otherSources = getJoined(entry, "other_sources");
  const itemTypes = [...new Set(getProps(entry, "item_type").map((v) => v.toUpperCase()))];
  const aboutPersons = getJoined(entry, "about_person", "; ");

  const notes = cleanNotes(entry);

  let line1 = `${sortWord}`;
  let line2 = `  ${title}`;
  if (author) line2 += ` / ${author}`;
  line2 += `. - В: ${source}`;
  if (number) line2 += `. - бр. ${number}`;
  line2 += `, (${year}), ${pages}`;
  if (otherSources) line2 += `. – ${otherSources}`;

  let itemTypeLine = "";
  if (itemTypes.length > 0) {
    itemTypeLine = `Item types: ${itemTypes.join(", ")}`;
  }

  return { mainLine: `${line1}\n${line2}`, notes, itemTypeLine, aboutPersons };
}

function formatOther(entry) {
  const author = getFirst(entry, "author") || "";
  let title = getFirst(entry, "title") || "";
  const year = getFirst(entry, "year") || "";
  const itemTypes = [...new Set(getProps(entry, "item_type").map((v) => v.toUpperCase()))];
  const notes = cleanNotes(entry);
  const aboutPersons = getJoined(entry, "about_person", "; ");

  let line1 = `${author}`;
  let line2 = `  ${title}`;
  if (year) line2 += ` (${year})`;

  let itemTypeLine = "";
  if (itemTypes.length > 0) {
    itemTypeLine = `Item types: ${itemTypes.join(", ")}`;
  }

  return { mainLine: `${line1}\n${line2}`, notes, itemTypeLine, aboutPersons };
}

// ============================
// Parse and Sort
// ============================
const parsed = entries.map((entry) => {
  const itemTypes = getProps(entry, "item_type").map((v) => v.toUpperCase());
  const primaryType = itemTypes.length > 0 ? itemTypes[0] : "";
  const year = parseInt(getFirst(entry, "year"), 10) || 0;
  return { entry, itemTypes, itemType: primaryType, year };
});

const bookTypes = ["KNG", "GOI", "CDD"];
parsed.sort((a, b) => {
  const aIsBook = bookTypes.includes((a.itemType || "").toUpperCase());
  const bIsBook = bookTypes.includes((b.itemType || "").toUpperCase());
  if (aIsBook && !bIsBook) return -1;
  if (!aIsBook && bIsBook) return 1;
  return a.year - b.year;
});

const articleTypes = ["JOU", "KRA", "ARTICLE", "DRU", "NSP"];
const books = parsed.filter((p) => bookTypes.includes((p.itemType || "").toUpperCase()));
const articles = parsed.filter((p) => articleTypes.includes((p.itemType || "").toUpperCase()));
const others = parsed.filter(
  (p) =>
    !bookTypes.includes((p.itemType || "").toUpperCase()) &&
    !articleTypes.includes((p.itemType || "").toUpperCase())
);

// ============================
// Build DOCX
// ============================
const total = parsed.length;
const children = [];

children.push(
  new Paragraph({
    children: [
      new TextRun({
        text: `Общо записи: ${total} (Книги: ${books.length}, Статии: ${articles.length}, Други: ${others.length})`,
        bold: true,
        size: 24,
      }),
    ],
  }),
  new Paragraph({ text: "" })
);

function pushEntry(formatFn, entries) {
  entries.forEach((e) => {
    const { mainLine, notes, itemTypeLine, aboutPersons } = formatFn(e.entry);
    mainLine.split("\n").forEach((line) =>
      children.push(new Paragraph({ children: [new TextRun({ text: line, size: 24 })] }))
    );
    if (itemTypeLine)
      children.push(new Paragraph({ children: [new TextRun({ text: itemTypeLine, size: 24 })] }));
    if (aboutPersons)
      children.push(
        new Paragraph({
          children: [
            new TextRun({ text: "Имена на лица, за които става дума: ", bold: true, size: 24 }),
            new TextRun({ text: aboutPersons, size: 24 }),
          ],
        })
      );
    if (notes)
      notes.forEach((n) =>
        children.push(new Paragraph({ children: [new TextRun({ text: n, italics: true, size: 24 })] }))
      );
    children.push(new Paragraph({ text: "" }));
  });
}

if (books.length > 0) {
  children.push(new Paragraph({ children: [new TextRun({ text: "КНИГИ", bold: true, size: 24 })] }));
  pushEntry(formatBook, books);
}
if (articles.length > 0) {
  children.push(new Paragraph({ children: [new TextRun({ text: "СТАТИИ", bold: true, size: 24 })] }));
  pushEntry(formatArticle, articles);
}
if (others.length > 0) {
  children.push(new Paragraph({ children: [new TextRun({ text: "ДРУГИ", bold: true, size: 24 })] }));
  pushEntry(formatOther, others);
}

const doc = new Document({ sections: [{ children }] });

Packer.toBuffer(doc).then((buffer) => {
  fs.writeFileSync(outputPath, buffer);
  console.log(`Sorted DOCX saved to ${outputPath}`);
});
